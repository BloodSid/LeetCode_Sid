package leetcode.editor.cn;
//给定一个由 n 个节点组成的网络，用 n x n 个邻接矩阵 graph 表示。在节点网络中，只有当 graph[i][j] = 1 时，节点 i 能够直接
//连接到另一个节点 j。 
//
// 一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传
//播将继续，直到没有更多的节点可以被这种方式感染。 
//
// 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。 
//
// 我们可以从 initial 中删除一个节点，并完全移除该节点以及从该节点到任何其他节点的任何连接。 
//
// 请返回移除后能够使 M(initial) 最小化的节点。如果有多个节点满足条件，返回索引 最小的节点 。 
//
// 
//
// 
// 
//
// 示例 1： 
//
// 
//输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
//输出：0
// 
//
// 示例 2： 
//
// 
//输入：graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
//输出：1
// 
//
// 示例 3： 
//
// 
//输入：graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
//输出：1
// 
//
// 
//
// 提示： 
// 
//
// 
// n == graph.length 
// n == graph[i].length 
// 2 <= n <= 300 
// graph[i][j] 是 0 或 1. 
// graph[i][j] == graph[j][i] 
// graph[i][i] == 1 
// 1 <= initial.length < n 
// 0 <= initial[i] <= n - 1 
// initial 中每个整数都不同 
// 
//
// 👍 62 👎 0


/**
 * 尽量减少恶意软件的传播 II
 *
 * @author IronSid
 * @version 1.0
 * @since 2024-04-17 01:59:38 
 */
public class MinimizeMalwareSpreadIiSolution {
static
//leetcode submit region begin(Prohibit modification and deletion)
class Solution {

    private int n;
    private int[][] graph;
    private int exclude;

    public int minMalwareSpread(int[][] graph, int[] initial) {
        n = graph.length;
        this.graph = graph;
        int res = n;
        int mn = n + 1;
        // 枚举排除的节点
        for (int i : initial) {
            exclude = i;
            boolean[] vis = new boolean[n];
            for (int j : initial) {
                if (i == j) continue;
                dfs(j, -1, vis);
            }
            int cnt = 0;
            for (boolean vi : vis) {
                if (vi) cnt++;
            }
            if (cnt < mn) {
                mn = cnt;
                res = i;
            } else if (cnt == mn) {
                res = Math.min(res, i);
            }
        }
        return res;
    }

    void dfs(int cur, int pre, boolean[] vis) {
        vis[cur] = true;
        for (int nxt = 0; nxt < n; nxt++) {
            if (nxt == exclude) continue;
            if (graph[cur][nxt] == 1 && nxt != pre && !vis[nxt]) {
                dfs(nxt, cur, vis);
            }
        }
    }
}
//leetcode submit region end(Prohibit modification and deletion)

}
